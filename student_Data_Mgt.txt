student_Data_Mgt/
│
├── templates/                  ← HTML templates
│   ├── login.html
│   ├── student_profile.html
│   ├── teacher_dashboard.html
│   ├── admin_dashboard.html
│   ├── create_user.html
│   └── reset_password.html
│
├── __init__.py                 ← Flask app factory
├── auth.py                     ← Authentication routes
├── views.py                    ← Dashboard/views (role-based)
├── models.py                   ← DB Models
├── main.py                     ← Entry point
├── venv/                       ← Virtual environment


__init__.py

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager

db = SQLAlchemy()
login_manager = LoginManager()

def create_app():
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'vishal_key'
    app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://postgres:vishal%4011@localhost:5433/student_data_mgt_db'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    db.init_app(app)
    login_manager.init_app(app)
    login_manager.login_view = 'auth.login'

    from .models import User

    @login_manager.user_loader
    def load_user(user_id):
        return User.query.get(int(user_id))

    from .auth import auth
    from .views import views
    app.register_blueprint(auth)
    app.register_blueprint(views)

    return app


models.py


import uuid
from . import db
from flask_login import UserMixin
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from werkzeug.security import generate_password_hash, check_password_hash

class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password_hash = db.Column(db.String(200), nullable=False)
    role = db.Column(db.String(20), nullable=False)  # 'admin', 'teacher', 'student'

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)


class PersonalInfo(db.Model):
    __tablename__ = 'personal_info'
    registration_no = db.Column(db.Integer, primary_key=True)
    uuid = db.Column(UUID(as_uuid=True), default=uuid.uuid4, unique=True, nullable=False, index=True)

    name = db.Column(db.String(50), nullable=False)
    gender = db.Column(db.String(10), nullable=False)
    email = db.Column(db.String(100), unique=True)
    phone_number = db.Column(db.String(15))

    sports = relationship('Sports', backref='student', cascade='all, delete-orphan')
    classes = relationship('ClassInfo', backref='student', cascade='all, delete-orphan')


class Sports(db.Model):
    __tablename__ = 'sports'
    sport_id = db.Column(db.Integer, primary_key=True)
    uuid = db.Column(UUID(as_uuid=True), default=uuid.uuid4, unique=True, nullable=False, index=True)

    registration_no = db.Column(db.Integer, db.ForeignKey('personal_info.registration_no', ondelete='CASCADE'), nullable=False)
    sport_name = db.Column(db.String(100), nullable=False)
    team_name = db.Column(db.String(100))
    coach_name = db.Column(db.String(100))
    ranking = db.Column(db.Integer)


class ClassInfo(db.Model):
    __tablename__ = 'class_info'
    roll_no = db.Column(db.String(20), primary_key=True)
    uuid = db.Column(UUID(as_uuid=True), default=uuid.uuid4, unique=True, nullable=False, index=True)

    registration_no = db.Column(db.Integer, db.ForeignKey('personal_info.registration_no', ondelete='CASCADE'), nullable=False)
    class_name = db.Column(db.String(50), nullable=False)
    section = db.Column(db.String(10))
    academic_year = db.Column(db.String(20))
    batch = db.Column(db.String(50))



auth.py

from flask import Blueprint, render_template, redirect, request, flash, url_for
from flask_login import login_user, logout_user, login_required
from .models import User
from . import db

auth = Blueprint('auth', __name__)

@auth.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form['email']
        password = request.form['password']

        user = User.query.filter_by(email=email).first()
        if user and user.check_password(password):
            login_user(user)
            return redirect(url_for('views.dashboard'))

        flash("Invalid credentials", "danger")

    return render_template('login.html')


@auth.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('auth.login'))


views.py


from flask import Blueprint, render_template, request, redirect, url_for, flash
from flask_login import login_required, current_user
from .models import PersonalInfo, Sports, ClassInfo, User
from . import db
from functools import wraps

views = Blueprint('views', __name__)

def role_required(*roles):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            if current_user.role not in roles:
                flash("Access denied", "danger")
                return redirect(url_for('views.dashboard'))
            return func(*args, **kwargs)
        return wrapper
    return decorator

@views.route('/')
@login_required
def dashboard():
    if current_user.role == 'admin':
        return render_template('admin_dashboard.html')
    elif current_user.role == 'teacher':
        return render_template('teacher_dashboard.html')
    else:
        return render_template('student_profile.html', user=current_user)


@views.route('/admin/create-user', methods=['GET', 'POST'])
@login_required
@role_required('admin')
def create_user():
    if request.method == 'POST':
        email = request.form['email']
        password = request.form['password']
        role = request.form['role']
        user = User(email=email, role=role)
        user.set_password(password)
        db.session.add(user)
        db.session.commit()
        flash("User created successfully", "success")
        return redirect(url_for('views.dashboard'))
    return render_template('create_user.html')


main.py

from student_Data_Mgt import create_app

app = create_app()

if __name__ == '__main__':
    app.run(debug=True)




